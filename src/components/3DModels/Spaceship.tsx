/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.2.16 spaceshipOptimized.glb -t -T -o Spaceship.tsx 
Files: spaceshipOptimized.glb [18.75MB] > C:\Users\mateu\OneDrive\Documentos\Coding\Schorn.io Codebase\mobile_vr_experience\spaceshipOptimized-transformed.glb [166.62KB] (99%)
Author: Exiolite (https://sketchfab.com/Exiolite)
License: CC-BY-4.0 (http://creativecommons.org/licenses/by/4.0/)
Source: https://sketchfab.com/3d-models/spaceship-carelia-9f0b7bb00d6241ac80e772b79d6cecce
Title: SpaceShip "Carelia"
*/

import * as THREE from "three";
import { useGLTF } from "@react-three/drei";
import { GLTF } from "three-stdlib";
import { toRotation } from "../../utils/toRotation";
import { toPosition } from "../../utils/toPosition";
import { PATH_3D_MODELS } from "./path";
import { schornColors } from "../../constants/schornColors";
import { KeyboardEvent, useEffect, useRef, useState } from "react";
import { useFrame } from "@react-three/fiber";
import { Laser, LaserProps } from "./Laser";
import { fromPixelsToMeters } from "../../utils/fromPixelsToMeters";

type GLTFResult = GLTF & {
  nodes: {
    Cube001_Material007_0: THREE.Mesh;
    Cube001_Engines_0: THREE.Mesh;
    Cube001_Glass_0: THREE.Mesh;
    Cube001_Weapons_0: THREE.Mesh;
  };
  materials: {
    ["Material.007"]: THREE.MeshStandardMaterial;
    Engines: THREE.MeshStandardMaterial;
    Glass: THREE.MeshStandardMaterial;
    Weapons: THREE.MeshStandardMaterial;
  };
};

export function Spaceship() {
  const { nodes, materials } = useGLTF(
    `${PATH_3D_MODELS}/spaceshipOptimized-transformed.glb`
  ) as GLTFResult;
  const ref = useRef<THREE.Group | null>(null);
  const [movement, setMovement] = useState({
    up: false,
    down: false,
    left: false,
    right: false,
  });
  const speed = 1;
  const [lasers, setLasers] = useState<LaserProps[]>([]);

  useEffect(() => {
    const handleKeyDown = (e) => {
      console.log("I was pressed");

      switch (e.key) {
        case "w":
          setMovement((m) => ({ ...m, up: true }));
          break;
        case "s":
          setMovement((m) => ({ ...m, down: true }));
          break;
        case "a":
          setMovement((m) => ({ ...m, left: true }));
          break;
        case "d":
          setMovement((m) => ({ ...m, right: true }));
          break;
      }
    };

    const handleKeyUp = (e) => {
      switch (e.key) {
        case "w":
          setMovement((m) => ({ ...m, up: false }));
          break;
        case "s":
          setMovement((m) => ({ ...m, down: false }));
          break;
        case "a":
          setMovement((m) => ({ ...m, left: false }));
          break;
        case "d":
          setMovement((m) => ({ ...m, right: false }));
          break;
      }
    };

    window.addEventListener("keydown", handleKeyDown);
    window.addEventListener("keyup", handleKeyUp);

    return () => {
      window.removeEventListener("keydown", handleKeyDown);
      window.removeEventListener("keyup", handleKeyUp);
    };
  }, []);

  useEffect(() => {
    const fireLaser = (e) => {
      if (e.code === "Space" && ref.current) {
        const currentPosition = ref.current.position;
        ref.current.getWorldPosition(currentPosition);

        setLasers((lasers) => [
          ...lasers,
          {
            id: `laser-${lasers.length}`,
            position: currentPosition,
          },
        ]);
      }
    };

    window.addEventListener("keydown", fireLaser);

    return () => window.removeEventListener("keydown", fireLaser);
  }, []);

  useFrame(() => {
    if (ref.current) {
      const delta = speed / 10;
      let newPositionY = ref.current.position.y;
      let newPositionX = ref.current.position.x;

      if (movement.up) {
        newPositionY += delta;
      }
      if (movement.down) {
        newPositionY -= delta;
      }
      if (movement.left) {
        newPositionX -= delta;
      }
      if (movement.right) {
        newPositionX += delta;
      }

      const windowHalfX = fromPixelsToMeters(window.innerWidth / 2);
      const windowHalfY = fromPixelsToMeters(window.innerHeight / 2);

      newPositionX = Math.max(
        -windowHalfX,
        Math.min(windowHalfX, newPositionX)
      );
      newPositionY = Math.max(
        -windowHalfY,
        Math.min(windowHalfY, newPositionY)
      );

      ref.current.position.y = newPositionY;
      ref.current.position.x = newPositionX;
    }
  });

  return (
    <group>
      <group
        ref={ref}
        dispose={null}
        scale={0.4}
        position={toPosition({
          positionBottom: 3,
          positionIn: 6,
        })}
        rotation={toRotation({
          rotationXInDeg: -10,
          rotationYInRad: -Math.PI / 2,
        })}
      >
        <mesh
          geometry={nodes.Cube001_Material007_0.geometry}
          material={materials["Material.007"]}
        />
        <mesh
          geometry={nodes.Cube001_Engines_0.geometry}
          material={materials.Engines}
        />
        <mesh
          geometry={nodes.Cube001_Glass_0.geometry}
          material={materials.Glass}
        />
        <mesh
          geometry={nodes.Cube001_Weapons_0.geometry}
          material={materials.Weapons}
        />
      </group>

      {lasers.map((laser) => (
        <Laser key={laser.id} id={laser.id} position={laser.position} />
      ))}
    </group>
  );
}

useGLTF.preload(`${PATH_3D_MODELS}/spaceshipOptimized-transformed.glb`);
